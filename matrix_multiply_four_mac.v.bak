module matrix_multiply_four_mac(

	input clk, start, reset, 
	output reg done, 
	output reg [10:0] clock_count

);

	parameter IDLE = 3'h0;
	parameter MULTIPLIER = 3'h1;
	parameter ACCUMULATE = 3'h2;
	parameter DONE = 3'h3;
	
	reg [2:0] state, state_c;
				
	reg [3:0] counter;
	
	reg [10:0] clock_count_c;
	
	reg done_c;
	
	// Init matrix A and matrix B
	reg signed [7:0] matrix_A [63:0];
	reg signed [7:0] matrix_B [63:0];
	ram_output RAMOUTPUT();
	
	// Matrix traverse
	reg [3:0] i_r, j_r, k_r;
	reg [3:0] i_s, j_s, k_s;
	reg [3:0] i, j, k;

	reg [3:0] l_r, m_r, n_r;
	reg [3:0] l_s, m_s, n_s;
	reg [3:0] l, m, n;

	
	initial begin
		$readmemb("ram_a_init.txt",matrix_A);
		$readmemb("ram_b_init.txt",matrix_B);
		
		i = 0;
		j = 0;
		k = 0;
		
		l = 4;
		m = 0;
		n = 0;
	end
	
	// MACs init
	reg macc_clear0, macc_clear1;
	reg signed [7:0] inA0, inB0, inA1, inB1;
	wire signed [18:0] out0, out1;
	MAC m0(.inA(inA0), .inB(inB0), .macc_clear(macc_clear0), .clk(clk), .out(out0));
	MAC m1(.inA(inA1), .inB(inB1), .macc_clear(macc_clear1), .clk(clk), .out(out1));
	
	// Buffer init
	reg signed [18:0] to_buffer1, to_buffer2;
	reg [5:0] to_buffer1_addr, to_buffer2_addr;
	wire [5:0] addr_out;
	wire signed [18:0] buffer_out;
	reg start_buff, start_c;
	
	receiving_buffer b0(.data1(to_buffer1), .data2(to_buffer2), 
								.clk(clk), .addr1(to_buffer1_addr), .addr2(to_buffer2_addr),
								.addr_out(addr_out), .data_out(buffer_out), .start(start_buff));
	
	always @(posedge clk) begin
		state <= state_c;
		done <= done_c;
		clock_count <= clock_count_c;
	end
	
	always @(posedge clk) begin
		// Two buffer delays, wait for MAC OUT and FSM
		i_r <= i;
		j_r <= j;
		k_r <= k;
		
		i_s <= i_r;
		j_s <= j_r;
		k_s <= k_r;
	
		l_r <= l;
		m_r <= m;
		n_r <= n;
		
		l_s <= l_r;
		m_s <= m_r;
		n_s <= n_r;
		
	end
	
	
	always @(posedge clk) begin
		// Write to buffer which will write to ram
		if (k_s == 7 && n_s == 7) begin
			start_buff <= 1;
			to_buffer1 <= out0;
			to_buffer1_addr <= 8*i_s+j_s;
			to_buffer2 <= out1;
			to_buffer2_addr <= 8*l_s+m_s;
		end else begin
			start_buff <= 0;
		end
		RAMOUTPUT.mem[addr_out] <= buffer_out;
	end
	
	always @(*) begin
		// Case when user pressed reset
		if (reset) begin
			state_c = IDLE;
		end
		
		// State allocation
		case (state)
		
			IDLE:
				begin
					done_c = 0;
					clock_count_c = 0;
					state_c = start ? MULTIPLIER : IDLE;
				end
				
			MULTIPLIER:
				begin
					// Start clock count
					clock_count_c = clock_count + 1;
					
					// Set MAC clear to 1
					macc_clear0 = 1;
					macc_clear1 = 1;
					
					// Fetch first element
					inA0 = matrix_A[j+8*k];
					inB0 = matrix_B[k+8*i];
					inA1 = matrix_A[m+8*n];
					inB1 = matrix_B[n+8*l]; 	
					
					// Go to accumulate state
					k = k + 1;
					n = n + 1;
					
					state_c = ACCUMULATE;
				end
				
			ACCUMULATE:
				begin
					// Continue clock count
					clock_count_c = clock_count + 1;
					
					// Turn off MAC clear because we accumulate
					macc_clear0 = 0;
					macc_clear1 = 0;
					
					// Fetch next product
					inA0 = matrix_A[j+8*k];
					inB0 = matrix_B[k+8*i];
					inA1 = matrix_A[m+8*n];
					inB1 = matrix_B[n+8*l]; 	
					
					
					// See if accumulate is done
					// Edit traverse
					k = k + 1;
					n = n + 1;
					if (k < 8 && n < 8) begin
						state_c = ACCUMULATE;
						start_c = 0;
					end else begin
						k = 0;
						n = 0;
						j = j + 1;
						m = m + 1;
						state_c = MULTIPLIER;
					end
						
					if ((i < 4 && j > 7) && (l < 8 && m > 7)) begin
						i = i + 1;
						l = l + 1;
						
						j = 0;
						m = 0;
					end
					
					// Priority exit
					if (i > 3 && l > 7) begin
						state_c = DONE;
					end
						
				end
				
			DONE:
				begin
					// Stays at this state until reset is pressed
					done_c = done;
					state_c = reset ? IDLE : DONE;
				end
				
		endcase
	end

endmodule